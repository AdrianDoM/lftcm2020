import tactic
import data.set.finite

/-
# (Re)-Building topological spaces in Lean

Mathlib has a large library of results on topological spaces, including various construcions,
separation axioms, Tychonoff's theorem, sheaves, Stone-Čech compactification, Heine-Cantor, to name
but a few.
See https://leanprover-community.github.io/theories/topology.html which for a summary of (a subset)
of what's in library.

But today we will ignore all that, and build our own version of topological spaces from scratch!
(On Friday morning Patrick Massot will lead a session exploring the existing mathlib library)

## What is a topological space:

There are many definitions: one from Wikipedia:

A topological space is an ordered pair (X, τ), where X is a set and τ is a collection of
subsets of X, satisfying the following axioms:
 - The empty set and X itself belong to τ.
 - Any arbitrary (finite or infinite) union of members of τ still belongs to τ.
 - The intersection of any finite number of members of τ still belongs to τ.

We can formalize this as follows.

-/

section topological_space

open set

structure topological_space_wiki :=
  (X : Type)  -- the underlying Type that the topology will be on
  (τ : set (set X)) -- the set of open subsets of X
  (empty_mem : ∅ ∈ τ) -- empty set is open
  (univ_mem : univ ∈ τ) -- whole space is open
  (union : ∀ B ⊆ τ, ⋃₀ B ∈ τ) -- arbitrary unions of opens are open
  (inter : ∀ (B ⊆ τ) (h : finite B), ⋂₀ B ∈ τ) -- finite intersections of opens are open

/-
But before we go on we should be sure we want to use this as our definition.
(Changing your definitions later can be less of a hassle in formalalized mathematics than pen and
paper maths as the proof assistant will tell you exactly which steps in which proofs you broke, its
still best to get it right the first time!)
-/

@[ext]
structure topological_space (X : Type) :=
  (opens : set (set X))
  (empty_mem : ∅ ∈ opens)
  (univ_mem : univ ∈ opens)
  (union : ∀ B ⊆ opens, ⋃₀ B ∈ opens)
  (inter : ∀ (A ∈ opens) (B ∈ opens), A ∩ B ∈ opens)


/-

## Exercise 0:
One of the axioms of a topological space we have here is unnecessary, it follows from the others.
If we remove it we'll have less work to do each time we want to show something is a topological space.

1. Identify and remove the uneeded axiom.

However we will undoubtedly still want to use this property so:

2. Add the axiom back as a lemma and prove it based on the others.

-/

def discrete (X : Type) : topological_space X :=
{ opens := univ,
  empty_mem := trivial,
  univ_mem := trivial,
  union := begin intros B h, trivial, end,
  inter := begin intros A hA B hB, trivial, end }

/-
As mentioned, there are many definitions of a topological space, for instance one can define them
via specifying a set of closed sets satisfying various axioms, this is equivalent and sometimes more
convenient.

We could set up two distinct definitions of two distinct Types defined by different data and provide
an equivalence between theses types, e.g. `topological_space_via_open_sets` and
`topological_space_via_closed_sets`, but this would quickly get unweildy. What's better is to
make an alternative _constructor_ for our original topological space. This is a function takes a set
of subsets satisfying the axioms to be the closed sets of a topological space and creates the
topological space defined by the corresponding set of open sets.
-/

def mk_closed_sets
  (X : Type)
  (σ : set (set X))
  (empty_mem : ∅ ∈ σ)
  (univ_mem : univ ∈ σ)
  (inter : ∀ B ⊆ σ, ⋂₀ B ∈ σ)
  (union : ∀ (A ∈ σ) (B ∈ σ), A ∪ B ∈ σ) :
topological_space X := {
  opens := set.image (λ S, Sᶜ) σ,
  empty_mem := begin
    rw set.mem_image,
    use univ,
    split,
    assumption,
    exact compl_univ,
  end,
  univ_mem := begin
    rw set.mem_image,
    use ∅,
    split,
    assumption,
    exact compl_empty,
  end,
  union := begin
    intros B hB,
    rw mem_image,
    use (⋃₀ B)ᶜ,
    split,
    rw compl_sUnion,
    apply inter,
    intros b hb,
    sorry,
    exact compl_compl',

  end,
  inter := _ }


/-
## Exercise 2

Another way me might want to create topological spaces in practice is to take the coarsest
possible topological space containing a given set of opens.
To define this we might say we want to define what the opens are given the set of generators,
So we want to define a set of opens by declaring that each generator will be open, and each
intersection of two opens will be open, and each union of a set of opens will be open, and finally
the empty and whole space (`univ`) must be open. The cleanest way to do this is as an inductive
definition.

The exercise is to make this definition of the topological space generated by a given set in Lean.
-/

/-
### Hint

As a hint for this exercise take a look at the following definition of a constructible set of a
topological space, defined by saying that an intersection of an open and a closed set is constructible
and that the union of any pair of constructible sets is constructible.

(Bonus exercise: mathlib doesn't have any theory of constructible sets, make one and PR it!)
-/

inductive is_constructible {X : Type} (T : topological_space X) : set X → Prop
-- Given two open sets in T, the intersection of one and the complement of the other is locally
-- closed, hence constructible
| locally_closed : ∀ (X ∈ T.opens) (Y ∈ T.opens), is_constructible (X ∩ Yᶜ)
-- Given two constructible sets their union is constructible
| union : ∀ X Y, is_constructible (X ∩ Yᶜ)

-- For example we can now use this definition to prove the empty set is constructible
example {X : Type} (T : topological_space X) : is_constructible T ∅ :=
begin
  -- The intersection of the whole space (open) with the empty set (closed) is locally closed, so
  -- constructible
  have := is_constructible.locally_closed univ T.univ_mem univ T.univ_mem,
  -- but that's just the empty set
  simp at this,
  exact this,
end

/-- The open sets of the least topology containing a collection of basic sets. -/
inductive generated_open (X : Type) (g : set (set X)) : set X → Prop
| -- sorry
basic  : ∀ s ∈ g, generated_open s
| univ   : generated_open univ
| inter  : ∀s t, generated_open s → generated_open t → generated_open (s ∩ t)
| sUnion : ∀k, (∀ s ∈  k, generated_open s) → generated_open (⋃₀ k)

lemma generated_open.empty (X : Type) (g : set (set X)) : generated_open X g ∅ :=
begin
  have := generated_open.sUnion (∅ : set (set X)),
  simp at this,
  exact this,
end

-- sorry

/-- The smallest topological space containing the collection `g` of basic sets -/
def generate_from (X : Type) (g : set (set X)) : topological_space X :=
{ opens          := /- inline sorry -/ generated_open X g/- inline sorry -/,
  empty_mem       := /- inline sorry -/generated_open.empty X g/- inline sorry -/,
  univ_mem       := /- inline sorry -/ generated_open.univ/- inline sorry -/,
  inter := /- inline sorry -/ begin intros A hA B hB, exact generated_open.inter A B hA hB, end/- inline sorry -/,
  union := /- inline sorry -/ generated_open.sUnion /- inline sorry -/ }

#check discrete

lemma a  (α : Type*) (a b : α) : set ({a, b} : set α) = ({(∅ : set α), {a}, {b}, {a,b}}  : set (set α)) :=
begin
    dsimp,
end

theorem subset_insert_iff {α : Type*} {a : α} (t: set α) ( s : set (set.insert a t)) : s ⊆ t ∨ ∃ s' ⊆ t, s = (s' ∪ {a}) :=
begin
  split,
end

def indiscrete (X : Type) : topological_space :=
{ X := X,
  opens := {∅, univ},
  empty := mem_insert ∅ {univ},
  univ := begin
    rw mem_insert_iff,
    right,
    exact mem_singleton univ,
  end,
  union := begin
    intros B h,
    rw finset.subset_insert_iff at h,
    sorry
  end,
  inter := sorry }

#print topological_space.ext

lemma indiscrete_eq_discrete : indiscrete unit = discrete unit :=
begin
  rw indiscrete,
  rw discrete,
  congr,

end
#print indiscrete_eq_discrete

end topological_space
